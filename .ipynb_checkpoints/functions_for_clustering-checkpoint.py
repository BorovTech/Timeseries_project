{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from collections import defaultdict\n",
    "import numpy as np\n",
    "from itertools import product\n",
    "from scipy.special import gamma\n",
    "from scipy.spatial.distance import pdist, squareform, euclidean\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "from random import randint"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def volume(r, m):\n",
    "    return np.pi ** (m / 2) * r ** m / gamma(m / 2 + 1)\n",
    "\n",
    "def significant(cluster, h, p):\n",
    "    max_diff = max(abs(p[i] - p[j]) for i, j in product(cluster, cluster))\n",
    "\n",
    "    return max_diff >= h\n",
    "\n",
    "def partition(dist, l, r, order):\n",
    "    if l == r:\n",
    "        return l\n",
    "\n",
    "    pivot = dist[order[(l + r) // 2]]\n",
    "    left, right = l - 1, r + 1\n",
    "    while True:\n",
    "        while True:\n",
    "            left += 1\n",
    "            if dist[order[left]] >= pivot:\n",
    "                break\n",
    "\n",
    "        while True:\n",
    "            right -= 1\n",
    "            if dist[order[right]] <= pivot:\n",
    "                break\n",
    "\n",
    "        if left >= right:\n",
    "            return right\n",
    "\n",
    "        order[left], order[right] = order[right], order[left]\n",
    "\n",
    "def nth_element(dist, order, k):\n",
    "    l = 0\n",
    "    r = len(order) - 1\n",
    "    while True:\n",
    "        if l == r:\n",
    "            break\n",
    "        m = partition(dist, l, r, order)\n",
    "        if m < k:\n",
    "            l = m + 1\n",
    "        elif m >= k:\n",
    "            r = m\n",
    "\n",
    "def get_clustering(x, k, h, verbose=True):\n",
    "    n = len(x)\n",
    "    if isinstance(x[0], list):\n",
    "        m = len(x[0])\n",
    "    else:\n",
    "        m = 1\n",
    "    dist = squareform(pdist(x)) #checkpoint №1\n",
    "\n",
    "    dk = []\n",
    "    for i in range(n):\n",
    "        order = list(range(n))\n",
    "        nth_element(dist[i], order, k - 1)\n",
    "        dk.append(dist[i][order[k - 1]])\n",
    "\n",
    "    p = [k / (volume(dk[i], m) * n) for i in range(n)]\n",
    "\n",
    "    w = np.full(n, 0)\n",
    "    completed = {0: False}\n",
    "    last = 1\n",
    "    vertices = set()\n",
    "    for d, i in sorted(zip(dk, range(n))):\n",
    "        neigh = set()\n",
    "        neigh_w = set()\n",
    "        clusters = defaultdict(list)\n",
    "        for j in vertices:\n",
    "            if dist[i][j] <= dk[i]:\n",
    "                neigh.add(j)\n",
    "                neigh_w.add(w[j])\n",
    "                clusters[w[j]].append(j)\n",
    "\n",
    "        vertices.add(i)\n",
    "        if len(neigh) == 0:\n",
    "            w[i] = last\n",
    "            completed[last] = False\n",
    "            last += 1\n",
    "        elif len(neigh_w) == 1:\n",
    "            wj = next(iter(neigh_w))\n",
    "            if completed[wj]:\n",
    "                w[i] = 0\n",
    "            else:\n",
    "                w[i] = wj\n",
    "        else:\n",
    "            if all(completed[wj] for wj in neigh_w):\n",
    "                w[i] = 0\n",
    "                continue\n",
    "            significant_clusters = set(wj for wj in neigh_w if significant(clusters[wj], h, p))\n",
    "            if len(significant_clusters) > 1:\n",
    "                w[i] = 0\n",
    "                for wj in neigh_w:\n",
    "                    if wj in significant_clusters:\n",
    "                        completed[wj] = (wj != 0)\n",
    "                    else:\n",
    "                        for j in clusters[wj]:\n",
    "                            w[j] = 0\n",
    "            else:\n",
    "                if len(significant_clusters) == 0:\n",
    "                    s = next(iter(neigh_w))\n",
    "                else:\n",
    "                    s = next(iter(significant_clusters))\n",
    "                w[i] = s\n",
    "                for wj in neigh_w:\n",
    "                    for j in clusters[wj]:\n",
    "                        w[j] = s\n",
    "    return w"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def index_element(i, partition, identifier):\n",
    "    if (identifier == \"max\"):\n",
    "        return i+arr[i:i+partition-1].index(max(arr[i:i+partition-1]))\n",
    "    else:\n",
    "        return i+arr[i:i+partition-1].index(min(arr[i:i+partition-1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO: поделить ряд на n // 2 участке и на каждом участке брать min и max \n",
    "def generate_z_vector_best(arr, n):\n",
    "    z_vector = []\n",
    "    partition = (len(arr) * 2) // n\n",
    "    for i in range(0,len(arr),partition):\n",
    "        z_vector.append(index_element(i, partition, \"max\"))\n",
    "        z_vector.append(index_element(i, partition, \"min\"))\n",
    "    return z_vector\n",
    "#я тут немного пошаманил и сделал дополнительную функцию чтобы наш говнокод выглядел хоть чуть-чуть получше"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
